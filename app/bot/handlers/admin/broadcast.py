# app/bot/handlers/admin/broadcast.py
from aiogram import Router, F, Bot
from aiogram.types import CallbackQuery, Message, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from aiogram.filters import StateFilter
from aiogram.types.input_media import InputMediaPhoto, InputMediaVideo
from sqlalchemy.orm import Session
from sqlalchemy import func, and_
from typing import List
import asyncio
from datetime import datetime, timedelta

from app.core.db import SessionLocal
from app.models.users import User
from app.models.investments import Investment
from app.bot.states.admin import AdminStates

router = Router()


def get_broadcast_menu_kb():
    """–ú–µ–Ω—é —Ä–∞—Å—Å—ã–ª–∫–∏"""
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="üë• –í—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º", callback_data="broadcast_all"),
                InlineKeyboardButton(text="‚ö° –¢–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–º", callback_data="broadcast_active")
            ],
            [
                InlineKeyboardButton(text="üè¶ –ü–æ –ø—É–ª–∞–º", callback_data="broadcast_pools"),
                InlineKeyboardButton(text="üí∞ –ü–æ —Å—É–º–º–µ –¥–µ–ø–æ–∑–∏—Ç–∞", callback_data="broadcast_amount")
            ],
            [
                InlineKeyboardButton(text="üìÖ –ü–æ –¥–∞—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏", callback_data="broadcast_date"),
                InlineKeyboardButton(text="üéØ –ö–∞—Å—Ç–æ–º–Ω–∞—è –≥—Ä—É–ø–ø–∞", callback_data="broadcast_custom")
            ],
            [
                InlineKeyboardButton(text="üîô –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="admin_menu")
            ]
        ]
    )


def get_pool_selection_kb():
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –≤—ã–±–æ—Ä–∞ –ø—É–ª–∞"""
    from app.core.config import settings

    buttons = []
    row = []

    for pool_name in settings.POOL_LIMITS.keys():
        row.append(InlineKeyboardButton(
            text=pool_name,
            callback_data=f"broadcast_pool_{pool_name}"
        ))
        if len(row) == 2:
            buttons.append(row)
            row = []

    if row:
        buttons.append(row)

    buttons.append([
        InlineKeyboardButton(text="üîô –ö —Ä–∞—Å—Å—ã–ª–∫–µ", callback_data="admin_broadcast")
    ])

    return InlineKeyboardMarkup(inline_keyboard=buttons)


def get_confirm_broadcast_kb(target_group: str, target_value: str = ""):
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Ä–∞—Å—Å—ã–ª–∫–∏"""
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="‚úÖ –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É",
                    callback_data=f"confirm_broadcast_{target_group}_{target_value}"
                )
            ],
            [
                InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="admin_broadcast")
            ]
        ]
    )


@router.callback_query(F.data == "admin_broadcast")
async def show_broadcast_menu(call: CallbackQuery, state: FSMContext):
    """–ü–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é —Ä–∞—Å—Å—ã–ª–∫–∏"""
    db = SessionLocal()

    try:
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        total_users = db.query(User).count()
        active_users = db.query(User).filter(User.deposit_usd > 0).count()

        text = (
            "üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π</b>\n\n"
            f"üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total_users:,}\n"
            f"‚ö° –ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {active_users:,}\n\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª–µ–≤—É—é –∞—É–¥–∏—Ç–æ—Ä–∏—é:"
        )

        await call.message.edit_text(text, reply_markup=get_broadcast_menu_kb())
        await state.set_state(AdminStates.broadcast_menu)

    finally:
        db.close()


@router.callback_query(StateFilter(AdminStates.broadcast_menu), F.data.startswith("broadcast_"))
async def select_broadcast_target(call: CallbackQuery, state: FSMContext):
    """–í—ã–±–æ—Ä —Ü–µ–ª–µ–≤–æ–π –≥—Ä—É–ø–ø—ã –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏"""
    target = call.data.split("_", 1)[1]

    if target == "all":
        await prepare_broadcast(call, state, "all", "")
    elif target == "active":
        await prepare_broadcast(call, state, "active", "")
    elif target == "pools":
        await call.message.edit_text(
            "üè¶ <b>–í—ã–±–µ—Ä–∏—Ç–µ –ø—É–ª:</b>",
            reply_markup=get_pool_selection_kb()
        )
        await state.set_state(AdminStates.broadcast_pool_selection)
    elif target == "amount":
        await call.message.edit_text(
            "üí∞ <b>–†–∞—Å—Å—ã–ª–∫–∞ –ø–æ —Å—É–º–º–µ –¥–µ–ø–æ–∑–∏—Ç–∞</b>\n\n"
            "–í–≤–µ–¥–∏—Ç–µ –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —Å—É–º–º—É –¥–µ–ø–æ–∑–∏—Ç–∞ –≤ –¥–æ–ª–ª–∞—Ä–∞—Ö:\n"
            "–ü—Ä–∏–º–µ—Ä: <code>100</code> (–¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –¥–µ–ø–æ–∑–∏—Ç–æ–º –æ—Ç $100)",
            parse_mode="HTML"
        )
        await state.set_state(AdminStates.broadcast_amount_input)
    elif target == "date":
        await call.message.edit_text(
            "üìÖ <b>–†–∞—Å—Å—ã–ª–∫–∞ –ø–æ –¥–∞—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏</b>\n\n"
            "–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –Ω–∞–∑–∞–¥:\n"
            "–ü—Ä–∏–º–µ—Ä: <code>7</code> (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π)\n"
            "–ò–ª–∏: <code>30</code> (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 30 –¥–Ω–µ–π)",
            parse_mode="HTML"
        )
        await state.set_state(AdminStates.broadcast_date_input)
    elif target == "custom":
        await call.message.edit_text(
            "üéØ <b>–ö–∞—Å—Ç–æ–º–Ω–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞</b>\n\n"
            "–í–≤–µ–¥–∏—Ç–µ TG ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é:\n"
            "–ü—Ä–∏–º–µ—Ä: <code>123456789, 987654321, 456789123</code>",
            parse_mode="HTML"
        )
        await state.set_state(AdminStates.broadcast_custom_input)


@router.callback_query(StateFilter(AdminStates.broadcast_pool_selection), F.data.startswith("broadcast_pool_"))
async def select_pool_for_broadcast(call: CallbackQuery, state: FSMContext):
    """–í—ã–±–æ—Ä –ø—É–ª–∞ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏"""
    pool_name = call.data.split("_", 2)[2]
    await prepare_broadcast(call, state, "pool", pool_name)


@router.message(StateFilter(AdminStates.broadcast_amount_input))
async def process_amount_input(msg: Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ —Å—É–º–º—ã –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏"""
    try:
        min_amount = float(msg.text.strip())
        if min_amount < 0:
            await msg.answer("‚ùå –°—É–º–º–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–π")
            return

        await prepare_broadcast(msg, state, "amount", str(min_amount))

    except ValueError:
        await msg.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—É–º–º—É –≤ –¥–æ–ª–ª–∞—Ä–∞—Ö")


@router.message(StateFilter(AdminStates.broadcast_date_input))
async def process_date_input(msg: Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –¥–∞—Ç—ã –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏"""
    try:
        days = int(msg.text.strip())
        if days < 1:
            await msg.answer("‚ùå –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –±–æ–ª—å—à–µ 0")
            return

        await prepare_broadcast(msg, state, "date", str(days))

    except ValueError:
        await msg.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π")


@router.message(StateFilter(AdminStates.broadcast_custom_input))
async def process_custom_input(msg: Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
    try:
        user_ids = [int(uid.strip()) for uid in msg.text.split(",")]
        if not user_ids:
            await msg.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω TG ID")
            return

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        db = SessionLocal()
        existing_users = db.query(User).filter(User.tg_id.in_(user_ids)).all()
        db.close()

        if not existing_users:
            await msg.answer("‚ùå –ù–∏ –æ–¥–∏–Ω –∏–∑ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return

        existing_ids = [str(user.tg_id) for user in existing_users]
        await prepare_broadcast(msg, state, "custom", ",".join(existing_ids))

    except ValueError:
        await msg.answer("‚ùå –í—Å–µ ID –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —á–∏—Å–ª–∞–º–∏")


async def prepare_broadcast(message, state: FSMContext, target_group: str, target_value: str):
    """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ —Ä–∞—Å—Å—ã–ª–∫–µ - –∑–∞–ø—Ä–æ—Å —Å–æ–æ–±—â–µ–Ω–∏—è"""
    db = SessionLocal()

    try:
        # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —Ü–µ–ª–µ–≤—É—é –∞—É–¥–∏—Ç–æ—Ä–∏—é
        user_count = await get_target_users_count(db, target_group, target_value)

        if user_count == 0:
            await message.answer("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏")
            return

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–∞—Å—Å—ã–ª–∫–∏
        await state.update_data(
            broadcast_target=target_group,
            broadcast_value=target_value,
            broadcast_count=user_count
        )

        # –û–ø–∏—Å–∞–Ω–∏–µ —Ü–µ–ª–µ–≤–æ–π –≥—Ä—É–ø–ø—ã
        group_descriptions = {
            "all": "–≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º",
            "active": "–∞–∫—Ç–∏–≤–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º",
            "pool": f"–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –ø—É–ª–∞ {target_value}",
            "amount": f"–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º —Å –¥–µ–ø–æ–∑–∏—Ç–æ–º –æ—Ç ${target_value}",
            "date": f"–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ {target_value} –¥–Ω–µ–π",
            "custom": "–≤—ã–±—Ä–∞–Ω–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º"
        }

        group_desc = group_descriptions.get(target_group, "–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º")

        text = (
            f"üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ {group_desc}</b>\n\n"
            f"üë• –ü–æ–ª—É—á–∞—Ç–µ–ª–µ–π: {user_count:,}\n\n"
            "–¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.\n\n"
            "<b>–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è:</b>\n"
            "‚Ä¢ –¢–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º\n"
            "‚Ä¢ –§–æ—Ç–æ —Å –ø–æ–¥–ø–∏—Å—å—é\n"
            "‚Ä¢ –í–∏–¥–µ–æ —Å –ø–æ–¥–ø–∏—Å—å—é\n"
            "‚Ä¢ –ö–Ω–æ–ø–∫–∏ (–±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã)\n\n"
            "‚ùó –°–æ–æ–±—â–µ–Ω–∏–µ –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ —Ç–æ–º –∂–µ –≤–∏–¥–µ, —á—Ç–æ –∏ –≤—ã –ø—Ä–∏—à–ª–µ—Ç–µ"
        )

        await message.answer(text, parse_mode="HTML")
        await state.set_state(AdminStates.broadcast_message_input)

    finally:
        db.close()


@router.message(StateFilter(AdminStates.broadcast_message_input))
async def process_broadcast_message(msg: Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏"""
    data = await state.get_data()
    target_group = data.get("broadcast_target")
    target_value = data.get("broadcast_value", "")
    user_count = data.get("broadcast_count", 0)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏
    broadcast_data = {
        "message_type": None,
        "text": None,
        "photo": None,
        "video": None,
        "reply_markup": None,
        "entities": None
    }

    if msg.photo:
        broadcast_data["message_type"] = "photo"
        broadcast_data["photo"] = msg.photo[-1].file_id
        broadcast_data["text"] = msg.caption
        broadcast_data["entities"] = msg.caption_entities
        broadcast_data["reply_markup"] = msg.reply_markup
    elif msg.video:
        broadcast_data["message_type"] = "video"
        broadcast_data["video"] = msg.video.file_id
        broadcast_data["text"] = msg.caption
        broadcast_data["entities"] = msg.caption_entities
        broadcast_data["reply_markup"] = msg.reply_markup
    elif msg.text:
        broadcast_data["message_type"] = "text"
        broadcast_data["text"] = msg.text
        broadcast_data["entities"] = msg.entities
        broadcast_data["reply_markup"] = msg.reply_markup
    else:
        await msg.answer("‚ùå –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è, —Ñ–æ—Ç–æ –∏ –≤–∏–¥–µ–æ")
        return

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
    await state.update_data(broadcast_message=broadcast_data)

    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–µ–≤—å—é
    group_descriptions = {
        "all": "–≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º",
        "active": "–∞–∫—Ç–∏–≤–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º",
        "pool": f"–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –ø—É–ª–∞ {target_value}",
        "amount": f"–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º —Å –¥–µ–ø–æ–∑–∏—Ç–æ–º –æ—Ç ${target_value}",
        "date": f"–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ {target_value} –¥–Ω–µ–π",
        "custom": "–≤—ã–±—Ä–∞–Ω–Ω—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º"
    }

    group_desc = group_descriptions.get(target_group, "–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º")

    preview_text = (
        f"üì¢ <b>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏</b>\n\n"
        f"üë• –ü–æ–ª—É—á–∞—Ç–µ–ª–µ–π: {user_count:,}\n"
        f"üéØ –ì—Ä—É–ø–ø–∞: {group_desc}\n\n"
        "üìù <b>–°–æ–æ–±—â–µ–Ω–∏–µ –≥–æ—Ç–æ–≤–æ –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ</b>\n"
        "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —Ä–∞—Å—Å—ã–ª–∫—É:"
    )

    await msg.answer(
        preview_text,
        reply_markup=get_confirm_broadcast_kb(target_group, target_value),
        parse_mode="HTML"
    )


@router.callback_query(F.data.startswith("confirm_broadcast_"))
async def confirm_and_send_broadcast(call: CallbackQuery, bot: Bot, state: FSMContext):
    """–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ä–∞—Å—Å—ã–ª–∫–∏"""
    data = await state.get_data()
    broadcast_data = data.get("broadcast_message")
    target_group = data.get("broadcast_target")
    target_value = data.get("broadcast_value", "")

    if not broadcast_data:
        await call.answer("‚ùå –î–∞–Ω–Ω—ã–µ —Ä–∞—Å—Å—ã–ª–∫–∏ –ø–æ—Ç–µ—Ä—è–Ω—ã")
        return

    await call.message.edit_text(
        "üöÄ <b>–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞...</b>\n\n"
        "–≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è",
        parse_mode="HTML"
    )

    # –ó–∞–ø—É—Å–∫–∞–µ–º —Ä–∞—Å—Å—ã–ª–∫—É –≤ —Ñ–æ–Ω–µ
    asyncio.create_task(
        execute_broadcast(bot, call.from_user.id, broadcast_data, target_group, target_value)
    )

    await state.clear()


async def execute_broadcast(bot: Bot, admin_id: int, broadcast_data: dict, target_group: str, target_value: str):
    """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏"""
    db = SessionLocal()

    try:
        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        users = await get_target_users(db, target_group, target_value)

        if not users:
            await bot.send_message(admin_id, "‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏")
            return

        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏
        sent_count = 0
        failed_count = 0
        blocked_count = 0

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
        for user in users:
            try:
                await asyncio.sleep(0.05)  # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –æ—Ç–ø—Ä–∞–≤–∫–∞–º–∏

                if broadcast_data["message_type"] == "text":
                    await bot.send_message(
                        chat_id=user.tg_id,
                        text=broadcast_data["text"],
                        entities=broadcast_data["entities"],
                        reply_markup=broadcast_data["reply_markup"]
                    )
                elif broadcast_data["message_type"] == "photo":
                    await bot.send_photo(
                        chat_id=user.tg_id,
                        photo=broadcast_data["photo"],
                        caption=broadcast_data["text"],
                        caption_entities=broadcast_data["entities"],
                        reply_markup=broadcast_data["reply_markup"]
                    )
                elif broadcast_data["message_type"] == "video":
                    await bot.send_video(
                        chat_id=user.tg_id,
                        video=broadcast_data["video"],
                        caption=broadcast_data["text"],
                        caption_entities=broadcast_data["entities"],
                        reply_markup=broadcast_data["reply_markup"]
                    )

                sent_count += 1

            except Exception as e:
                error_str = str(e).lower()
                if "blocked" in error_str or "chat not found" in error_str:
                    blocked_count += 1
                else:
                    failed_count += 1

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç—á–µ—Ç –∞–¥–º–∏–Ω—É
        report = (
            f"üìä <b>–û—Ç—á–µ—Ç –æ —Ä–∞—Å—Å—ã–ª–∫–µ</b>\n\n"
            f"‚úÖ –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {sent_count:,}\n"
            f"üö´ –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã: {blocked_count:,}\n"
            f"‚ùå –û—à–∏–±–∫–∏: {failed_count:,}\n"
            f"üìã –í—Å–µ–≥–æ: {len(users):,}\n\n"
            f"üìà –£—Å–ø–µ—à–Ω–æ—Å—Ç—å: {(sent_count / len(users) * 100):.1f}%"
        )

        await bot.send_message(admin_id, report, parse_mode="HTML")

    finally:
        db.close()


async def get_target_users_count(db: Session, target_group: str, target_value: str) -> int:
    """–ü–æ–¥—Å—á–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏"""
    query = db.query(User)

    if target_group == "all":
        return query.count()
    elif target_group == "active":
        return query.filter(User.deposit_usd > 0).count()
    elif target_group == "pool":
        # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Å –∞–∫—Ç–∏–≤–Ω—ã–º–∏ –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏—è–º–∏ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–º –ø—É–ª–µ
        user_ids = db.query(Investment.user_id).filter(
            and_(Investment.pool_name == target_value, Investment.is_active == True)
        ).distinct().subquery()
        return query.filter(User.id.in_(user_ids)).count()
    elif target_group == "amount":
        min_amount = float(target_value)
        return query.filter(User.deposit_usd >= min_amount).count()
    elif target_group == "date":
        days_ago = int(target_value)
        date_threshold = datetime.utcnow() - timedelta(days=days_ago)
        return query.filter(User.created_at >= date_threshold).count()
    elif target_group == "custom":
        user_ids = [int(uid) for uid in target_value.split(",")]
        return query.filter(User.tg_id.in_(user_ids)).count()

    return 0


async def get_target_users(db: Session, target_group: str, target_value: str) -> List[User]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏"""
    query = db.query(User)

    if target_group == "all":
        return query.all()
    elif target_group == "active":
        return query.filter(User.deposit_usd > 0).all()
    elif target_group == "pool":
        # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Å –∞–∫—Ç–∏–≤–Ω—ã–º–∏ –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏—è–º–∏ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–º –ø—É–ª–µ
        user_ids = db.query(Investment.user_id).filter(
            and_(Investment.pool_name == target_value, Investment.is_active == True)
        ).distinct().subquery()
        return query.filter(User.id.in_(user_ids)).all()
    elif target_group == "amount":
        min_amount = float(target_value)
        return query.filter(User.deposit_usd >= min_amount).all()
    elif target_group == "date":
        days_ago = int(target_value)
        date_threshold = datetime.utcnow() - timedelta(days=days_ago)
        return query.filter(User.created_at >= date_threshold).all()
    elif target_group == "custom":
        user_ids = [int(uid) for uid in target_value.split(",")]
        return query.filter(User.tg_id.in_(user_ids)).all()

    return []